
class State:
    def __init__(self, position=None, velocity=None, heading=None, history_size=20):
        """
        Initialize state with xyz-vectors for position, velocity, and heading.

        Args:
            position: [x, y, z] coordinates
            velocity: [vx, vy, vz] velocity components
            heading: [hx, hy, hz] heading vector
            history_size: Number of previous states to store
        """
        self.position = position if position is not None else [0.0, 0.0, 0.0]
        self.velocity = velocity if velocity is not None else [0.0, 0.0, 0.0]
        self.heading = heading if heading is not None else [1.0, 0.0, 0.0]

        # History tracking
        self.history_size = history_size
        self.position_history = []
        self.velocity_history = []
        self.heading_history = []
        self.timestamp_history = []

    def add_to_history(self, timestamp=None):
        """
        Add current state to history buffer.

        Args:
            timestamp: Optional timestamp for this state
        """
        self.position_history.append(self.position.copy())
        self.velocity_history.append(self.velocity.copy())
        self.heading_history.append(self.heading.copy())
        self.timestamp_history.append(timestamp)

        # Keep only the last N states
        if len(self.position_history) > self.history_size:
            self.position_history.pop(0)
            self.velocity_history.pop(0)
            self.heading_history.pop(0)
            self.timestamp_history.pop(0) 


def update_trajectory(state, time_horizon=5.0, time_step=0.1, use_history=True):
    """
    Project the drone's future path based on current state and historical data.

    Args:
        state: State object containing position, velocity, and heading
        time_horizon: How far into the future to project (seconds)
        time_step: Time interval between trajectory points (seconds)
        use_history: If True, use historical data to estimate acceleration

    Returns:
        trajectory: List of [x, y, z] positions representing the projected path
    """
    trajectory = []

    # Start from current position and velocity
    current_pos = state.position.copy()
    current_vel = state.velocity.copy()

    # Estimate acceleration from history
    acceleration = [0.0, 0.0, 0.0]
    if use_history and len(state.velocity_history) >= 2:
        # Calculate average acceleration from recent velocity changes
        recent_accels = [[], [], []]  # x, y, z components

        for i in range(len(state.velocity_history) - 1):
            for axis in range(3):
                vel_change = state.velocity_history[i + 1][axis] - state.velocity_history[i][axis]
                # Assuming uniform time steps (you can use timestamp_history for actual dt)
                recent_accels[axis].append(vel_change)

        # Average acceleration for each axis
        for axis in range(3):
            if recent_accels[axis]:
                acceleration[axis] = sum(recent_accels[axis]) / len(recent_accels[axis])

    # Generate trajectory points with acceleration
    num_steps = int(time_horizon / time_step)
    for _ in range(num_steps + 1):
        # Store current position
        trajectory.append(current_pos.copy())

        # Update position using current velocity
        current_pos[0] += current_vel[0] * time_step
        current_pos[1] += current_vel[1] * time_step
        current_pos[2] += current_vel[2] * time_step

        # Update velocity using estimated acceleration
        current_vel[0] += acceleration[0] * time_step
        current_vel[1] += acceleration[1] * time_step
        current_vel[2] += acceleration[2] * time_step

    return trajectory


def update_trajectory_polynomial(state, time_horizon=5.0, time_step=0.1, poly_degree=2):
    """
    Project the drone's future path using polynomial curve fitting on historical data.
    This can capture more complex motion patterns like turns and curved paths.

    Args:
        state: State object containing position, velocity, and heading
        time_horizon: How far into the future to project (seconds)
        time_step: Time interval between trajectory points (seconds)
        poly_degree: Degree of polynomial to fit (2=quadratic, 3=cubic, etc.)

    Returns:
        trajectory: List of [x, y, z] positions representing the projected path
    """
    import numpy as np

    # Need at least poly_degree + 1 history points
    min_points = poly_degree + 1
    if len(state.position_history) < min_points:
        # Fall back to simpler method
        return update_trajectory(state, time_horizon, time_step, use_history=True)

    # Extract historical positions
    history = np.array(state.position_history)
    n_history = len(history)

    # Create time indices for historical data
    t_history = np.arange(-n_history + 1, 1)  # ..., -2, -1, 0

    # Fit polynomial for each axis
    poly_coeffs = []
    for axis in range(3):
        coeffs = np.polyfit(t_history, history[:, axis], poly_degree)
        poly_coeffs.append(coeffs)

    # Generate future trajectory
    trajectory = []
    num_steps = int(time_horizon / time_step)

    for step in range(num_steps + 1):
        t = step  # Time steps into the future
        pos = [
            np.polyval(poly_coeffs[0], t),
            np.polyval(poly_coeffs[1], t),
            np.polyval(poly_coeffs[2], t)
        ]
        trajectory.append(pos)

    return trajectory


class AdaptiveController:
    """
    Adaptive controller for 3D drone tracking using adaptive control law.
    Based on model reference adaptive control (MRAC) with parameter estimation.
    """

    def __init__(self, adaptation_gain=200.0, damping_gain=200.0, lambda_gain=10.0):
        """
        Initialize adaptive controller.

        Args:
            adaptation_gain: Gain matrix P for parameter adaptation (scalar, will create P*I)
            damping_gain: Damping gain Kd for control law (scalar, will create Kd*I)
            lambda_gain: Convergence rate for sliding variable
        """
        import numpy as np

        # Controller gains
        self.P = adaptation_gain * np.eye(9)  # 9 parameters for 3D drone model
        self.Kd = damping_gain * np.eye(3)    # 3D control (x, y, z)
        self.lambda_gain = lambda_gain

        # Estimated parameters (initially zero, will be adapted)
        # For drone: mass, drag coefficients (3), gravity effect, additional dynamics (4)
        self.ahat = np.zeros(9)

        # True physical parameters (can be set if known, or left as unknowns)
        self.mass = 1.0          # kg
        self.drag_x = 0.1        # drag coefficient x
        self.drag_y = 0.1        # drag coefficient y
        self.drag_z = 0.1        # drag coefficient z
        self.g = 9.81            # gravity

    def compute_control(self, state, desired_trajectory, t):
        """
        Compute adaptive control input for drone.

        Args:
            state: Current State object with position, velocity
            desired_trajectory: Dictionary with 'pos', 'vel', 'accel' for desired trajectory
            t: Current time

        Returns:
            control_force: [Fx, Fy, Fz] control forces
            adaptation_update: Update for estimated parameters
        """
        import numpy as np

        # Current state
        q = np.array(state.position)      # [x, y, z]
        qdot = np.array(state.velocity)   # [vx, vy, vz]

        # Desired trajectory
        qd = np.array(desired_trajectory['pos'])
        qd_dot = np.array(desired_trajectory['vel'])
        qd_ddot = np.array(desired_trajectory['accel'])

        # Tracking errors
        qtilde = q - qd
        qtilde_dot = qdot - qd_dot

        # Reference trajectory (for sliding surface)
        qr_dot = qd_dot - self.lambda_gain * qtilde
        qr_ddot = qd_ddot - self.lambda_gain * qtilde_dot

        # Sliding variable
        s = (qdot - qr_dot)

        # Construct regression matrix Y (3x9)
        # Each row corresponds to dynamics in x, y, z
        Y = self._build_regressor_matrix(q, qdot, qr_dot, qr_ddot)

        # Adaptive control law
        # tau = Y * ahat - Kd * s
        control_force = Y @ self.ahat - self.Kd @ s

        # Adaptation law: ahat_dot = -P * Y^T * s
        ahat_dot = -self.P @ Y.T @ s

        return control_force, ahat_dot

    def _build_regressor_matrix(self, q, qdot, qr_dot, qr_ddot):
        """
        Build the regression matrix Y for the drone dynamics.

        Drone dynamics model:
        m * qddot = F - D * qdot - G

        Where:
        - m: mass
        - D: drag matrix
        - G: gravity vector

        Linearly parameterized as: Y * a = required force
        Parameters a = [m, dx, dy, dz, g, c1, c2, c3, c4]
        """
        import numpy as np

        Y = np.zeros((3, 9))

        # Row 1: x-axis dynamics
        Y[0, 0] = qr_ddot[0]           # mass * acceleration
        Y[0, 1] = qdot[0] * qr_dot[0]  # drag term x
        Y[0, 5] = np.sin(q[2])         # coupling term 1

        # Row 2: y-axis dynamics
        Y[1, 0] = qr_ddot[1]           # mass * acceleration
        Y[1, 2] = qdot[1] * qr_dot[1]  # drag term y
        Y[1, 6] = np.cos(q[2])         # coupling term 2

        # Row 3: z-axis dynamics (includes gravity)
        Y[2, 0] = qr_ddot[2]           # mass * acceleration
        Y[2, 3] = qdot[2] * qr_dot[2]  # drag term z
        Y[2, 4] = 1.0                  # gravity term
        Y[2, 7] = np.cos(q[0])         # coupling term 3
        Y[2, 8] = np.cos(q[1])         # coupling term 4

        return Y

    def update_parameters(self, ahat_dot, dt):
        """
        Update estimated parameters using adaptation law.

        Args:
            ahat_dot: Rate of change of parameters
            dt: Time step
        """
        self.ahat += ahat_dot * dt

    def get_estimated_parameters(self):
        """
        Return current parameter estimates.

        Returns:
            Dictionary with estimated parameters
        """
        return {
            'mass_est': self.ahat[0],
            'drag_x_est': self.ahat[1],
            'drag_y_est': self.ahat[2],
            'drag_z_est': self.ahat[3],
            'gravity_est': self.ahat[4],
            'coupling_params': self.ahat[5:9]
        }


class DroneTracker:
    """
    Tracks a leader drone and computes desired trajectory for follower drone.
    Updates leader information periodically and predicts future trajectory.
    """

    def __init__(self, update_interval=3, prediction_method='polynomial'):
        """
        Initialize drone tracker.

        Args:
            update_interval: How often to update leader information (timesteps)
            prediction_method: 'polynomial' or 'acceleration' for trajectory prediction
        """
        self.leader_state = State(history_size=20)
        self.update_interval = update_interval
        self.prediction_method = prediction_method
        self.timestep_counter = 0
        self.predicted_trajectory = []
        self.last_update_time = 0

    def update_leader_state(self, position, velocity, heading=None, timestamp=None):
        """
        Update the leader drone's state (called every update_interval timesteps).

        Args:
            position: [x, y, z] position of leader
            velocity: [vx, vy, vz] velocity of leader
            heading: [hx, hy, hz] heading of leader (optional)
            timestamp: Current time
        """
        self.leader_state.position = position.copy() if hasattr(position, 'copy') else list(position)
        self.leader_state.velocity = velocity.copy() if hasattr(velocity, 'copy') else list(velocity)
        if heading is not None:
            self.leader_state.heading = heading.copy() if hasattr(heading, 'copy') else list(heading)

        # Add to history for trajectory prediction
        self.leader_state.add_to_history(timestamp=timestamp)
        self.last_update_time = timestamp if timestamp is not None else 0

        # Update predicted trajectory
        self._update_predicted_trajectory()

    def _update_predicted_trajectory(self):
        """Update the predicted future trajectory of the leader drone."""
        if self.prediction_method == 'polynomial':
            self.predicted_trajectory = update_trajectory_polynomial(
                self.leader_state,
                time_horizon=5.0,
                time_step=0.1,
                poly_degree=2
            )
        else:  # acceleration-based
            self.predicted_trajectory = update_trajectory(
                self.leader_state,
                time_horizon=5.0,
                time_step=0.1,
                use_history=True
            )

    def get_desired_trajectory(self, t, lookahead_time=0.5):
        """
        Get desired position, velocity, and acceleration for follower drone.

        Args:
            t: Current time
            lookahead_time: How far ahead to look on predicted trajectory (seconds)

        Returns:
            Dictionary with 'pos', 'vel', 'accel' for desired trajectory
        """
        import numpy as np

        # If no trajectory predicted yet, use current leader state
        if len(self.predicted_trajectory) == 0:
            return {
                'pos': np.array(self.leader_state.position),
                'vel': np.array(self.leader_state.velocity),
                'accel': np.array([0.0, 0.0, 0.0])
            }

        # Find the point in predicted trajectory at lookahead_time
        lookahead_steps = int(lookahead_time / 0.1)  # assuming 0.1s time_step
        lookahead_steps = min(lookahead_steps, len(self.predicted_trajectory) - 1)

        # Desired position (lookahead point)
        qd = np.array(self.predicted_trajectory[lookahead_steps])

        # Estimate desired velocity from trajectory
        if lookahead_steps > 0 and lookahead_steps < len(self.predicted_trajectory) - 1:
            next_pos = np.array(self.predicted_trajectory[lookahead_steps + 1])
            prev_pos = np.array(self.predicted_trajectory[lookahead_steps - 1])
            qd_dot = (next_pos - prev_pos) / 0.2  # centered difference
        else:
            qd_dot = np.array(self.leader_state.velocity)

        # Estimate desired acceleration
        if lookahead_steps > 1 and lookahead_steps < len(self.predicted_trajectory) - 2:
            pos_ahead = np.array(self.predicted_trajectory[lookahead_steps + 2])
            pos_behind = np.array(self.predicted_trajectory[lookahead_steps - 2])
            vel_ahead = (pos_ahead - qd) / 0.2
            vel_behind = (qd - pos_behind) / 0.2
            qd_ddot = (vel_ahead - vel_behind) / 0.2
        else:
            qd_ddot = np.array([0.0, 0.0, 0.0])

        return {
            'pos': qd,
            'vel': qd_dot,
            'accel': qd_ddot
        }

    def should_update(self, timestep):
        """
        Check if it's time to update leader information.

        Args:
            timestep: Current timestep number

        Returns:
            True if should update, False otherwise
        """
        return timestep % self.update_interval == 0
 
