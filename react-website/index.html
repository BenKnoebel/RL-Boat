<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RL Boat Telemetry</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            padding: 40px 20px;
            color: #1a1a1a;
        }

        #root {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 42px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 16px;
            color: #6b7280;
            font-weight: 400;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 24px;
            align-items: start;
        }

        .canvas-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            overflow: hidden;
            background: #fafafa;
            border: 1px solid #e5e7eb;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 12px;
            letter-spacing: -0.3px;
        }

        .muted {
            color: #6b7280;
            font-size: 14px;
            line-height: 1.6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-item {
            background: #f9fafb;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .stat-label {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #1a1a1a;
            font-variant-numeric: tabular-nums;
        }

        .stat-small {
            font-size: 14px;
            word-break: break-word;
        }

        .canvas-controls {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: #374151;
        }

        .badge-success {
            background: #d1fae5;
            border-color: #a7f3d0;
            color: #065f46;
        }

        .badge-danger {
            background: #fee2e2;
            border-color: #fecaca;
            color: #991b1b;
        }

        .instructions {
            background: #fefce8;
            border: 1px solid #fde047;
            border-radius: 8px;
            padding: 16px;
            margin-top: 8px;
        }

        .instructions-title {
            font-size: 14px;
            font-weight: 600;
            color: #854d0e;
            margin-bottom: 8px;
        }

        .instructions-list {
            list-style: none;
            font-size: 13px;
            color: #a16207;
            line-height: 1.6;
        }

        .instructions-list li {
            padding-left: 20px;
            position: relative;
        }

        .instructions-list li:before {
            content: "•";
            position: absolute;
            left: 8px;
        }

        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Boat Visualization App -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function BoatVisualization() {
            const canvasRef = useRef(null);
            const boatStateRef = useRef(null);
            const lastFrameTime = useRef(Date.now());

            const CANVAS_WIDTH = 1000;
            const CANVAS_HEIGHT = 1000;
            const BOAT_LENGTH = 10;
            const API_ENDPOINT = '/api/boat-state';
            const DEFAULT_BACKGROUND_SRC = './image.png';

            const [boatState, setBoatState] = useState({
                x: 500,
                y: 500,
                angle: 0,
                vx: 0,
                vy: 0,
                omega: 0
            });

            boatStateRef.current = boatState;

            const [backgroundImage, setBackgroundImage] = useState(null);
            const [fps, setFps] = useState(0);
            const [apiStatus, setApiStatus] = useState('connecting');
            const [lastUpdate, setLastUpdate] = useState(null);

            // Load the provided background map
            useEffect(() => {
                const img = new Image();
                img.onload = () => setBackgroundImage(img);
                img.onerror = () => console.warn('Unable to load default background image');
                img.src = DEFAULT_BACKGROUND_SRC;
            }, []);

            const normalizeHeading = (heading) => {
                if (!isFinite(heading)) return boatStateRef.current.angle;
                // If the value looks like degrees, convert to radians
                if (Math.abs(heading) > Math.PI * 2) {
                    return heading * Math.PI / 180;
                }
                return heading;
            };

            const upsertBoatStateFromApi = (payload) => {
                setBoatState((prev) => {
                    const next = { ...prev };

                    if (payload.position) {
                        if (typeof payload.position.x === 'number') next.x = payload.position.x;
                        if (typeof payload.position.y === 'number') next.y = payload.position.y;
                    }

                    if (typeof payload.heading === 'number') {
                        next.angle = normalizeHeading(payload.heading);
                    }

                    if (payload.velocity !== undefined) {
                        if (typeof payload.velocity === 'number') {
                            const angle = payload.heading ? normalizeHeading(payload.heading) : next.angle;
                            next.vx = payload.velocity * Math.cos(angle);
                            next.vy = payload.velocity * Math.sin(angle);
                        } else {
                            if (typeof payload.velocity.x === 'number') next.vx = payload.velocity.x;
                            if (typeof payload.velocity.y === 'number') next.vy = payload.velocity.y;
                        }
                    }

                    return next;
                });
            };

            // Poll the API for boat state (30 Hz)
            useEffect(() => {
                let isCancelled = false;

                const fetchBoatState = async () => {
                    try {
                        const response = await fetch(API_ENDPOINT);
                        if (!response.ok) throw new Error(`Status ${response.status}`);
                        const payload = await response.json();
                        if (isCancelled) return;
                        upsertBoatStateFromApi(payload);
                        setApiStatus('connected');
                        setLastUpdate(new Date());
                    } catch (error) {
                        if (isCancelled) return;
                        setApiStatus('error');
                    }
                };

                fetchBoatState();
                const interval = setInterval(fetchBoatState, 1000 / 30);
                return () => {
                    isCancelled = true;
                    clearInterval(interval);
                };
            }, []);

            // Draw boat on canvas
            const drawBoat = (ctx, state) => {
                const { x, y, angle } = state;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.beginPath();
                ctx.arc(0, 0, 16, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-BOAT_LENGTH/2, -BOAT_LENGTH/4, BOAT_LENGTH, BOAT_LENGTH/2);

                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(BOAT_LENGTH/2 + 4, 0);
                ctx.stroke();

                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.moveTo(BOAT_LENGTH/2 + 4, 0);
                ctx.lineTo(BOAT_LENGTH/2, -2.5);
                ctx.lineTo(BOAT_LENGTH/2, 2.5);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            };

            // Render at animation frame rate
            useEffect(() => {
                let animationFrame;

                const render = () => {
                    const canvas = canvasRef.current;
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');

                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    if (backgroundImage) {
                        ctx.drawImage(backgroundImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    } else {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                        ctx.strokeStyle = '#f3f4f6';
                        ctx.lineWidth = 1;
                        for (let i = 0; i <= CANVAS_WIDTH; i += 100) {
                            ctx.beginPath();
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i, CANVAS_HEIGHT);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(0, i);
                            ctx.lineTo(CANVAS_WIDTH, i);
                            ctx.stroke();
                        }
                    }

                    drawBoat(ctx, boatStateRef.current);

                    const now = Date.now();
                    const delta = now - lastFrameTime.current;
                    if (delta > 0) {
                        setFps(Math.round(1000 / delta));
                    }
                    lastFrameTime.current = now;

                    animationFrame = requestAnimationFrame(render);
                };

                render();
                return () => cancelAnimationFrame(animationFrame);
            }, [backgroundImage]);

            const speed = Math.sqrt(boatState.vx**2 + boatState.vy**2);
            const headingDeg = (boatState.angle * 180 / Math.PI).toFixed(1);
            const apiStatusLabel = apiStatus === 'connected'
                ? 'Connected'
                : apiStatus === 'error'
                    ? 'Error'
                    : 'Connecting...';
            const apiStatusBadge = apiStatus === 'connected'
                ? 'badge-success'
                : apiStatus === 'error'
                    ? 'badge-danger'
                    : '';

            return (
                <>
                    <div className="header">
                        <h1>RL Boat Telemetry</h1>
                        <p>Boat pose is supplied by API calls; canvas uses the provided background map.</p>
                    </div>

                    <div className="main-container">
                        <div className="canvas-section">
                            <div className="canvas-container">
                                <canvas
                                    ref={canvasRef}
                                    width={CANVAS_WIDTH}
                                    height={CANVAS_HEIGHT}
                                />
                            </div>

                            <div className="canvas-controls">
                                <span className="badge">1000 × 1000 px</span>
                                <span className={`badge ${fps >= 25 ? 'badge-success' : ''}`}>
                                    {fps} FPS
                                </span>
                                <span className={`badge ${backgroundImage ? 'badge-success' : ''}`}>
                                    {backgroundImage ? 'Background loaded' : 'Loading map...'}
                                </span>
                            </div>
                        </div>

                        <div className="sidebar">
                            <div className="card">
                                <h3 className="card-title">Background</h3>
                                <p className="muted">Using the provided image (<code>image.png</code>) as the standardized map.</p>
                            </div>

                            <div className="card">
                                <h3 className="card-title">API</h3>
                                <div className="stats-grid">
                                    <div className="stat-item">
                                        <div className="stat-label">Status</div>
                                        <div className="stat-value">
                                            <span className={`badge ${apiStatusBadge}`}>{apiStatusLabel}</span>
                                        </div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Endpoint</div>
                                        <div className="stat-value stat-small">{API_ENDPOINT}</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Last Update</div>
                                        <div className="stat-value stat-small">{lastUpdate ? lastUpdate.toLocaleTimeString() : 'Waiting...'}</div>
                                    </div>
                                </div>
                            </div>

                            <div className="card">
                                <h3 className="card-title">Telemetry</h3>
                                <div className="stats-grid">
                                    <div className="stat-item">
                                        <div className="stat-label">Position X</div>
                                        <div className="stat-value">{Math.round(boatState.x)}</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Position Y</div>
                                        <div className="stat-value">{Math.round(boatState.y)}</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Heading</div>
                                        <div className="stat-value">{headingDeg}°</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Speed</div>
                                        <div className="stat-value">{speed.toFixed(1)}</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Velocity X</div>
                                        <div className="stat-value">{boatState.vx.toFixed(2)}</div>
                                    </div>
                                    <div className="stat-item">
                                        <div className="stat-label">Velocity Y</div>
                                        <div className="stat-value">{boatState.vy.toFixed(2)}</div>
                                    </div>
                                </div>
                            </div>

                            <div className="instructions">
                                <div className="instructions-title">API Contract</div>
                                <ul className="instructions-list">
                                    <li>Expose <code>GET {API_ENDPOINT}</code> returning JSON.</li>
                                    <li>Expected fields: <code>position.x</code>, <code>position.y</code>, <code>velocity.x</code>/<code>velocity.y</code> (or scalar <code>velocity</code>), and <code>heading</code> (radians; degrees are auto-converted).</li>
                                    <li>Viewer polls at 5 Hz; each response overwrites the rendered boat pose.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<BoatVisualization />);
    </script>
</body>
</html>
